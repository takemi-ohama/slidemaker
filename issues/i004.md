# Issue #004: Phase 3 - 新規作成ワークフロー実装

## 概要

Phase 3として、Markdownファイルから最終的なPowerPointファイルまでの完全なワークフロー（新規作成パイプライン）を実装します。これにより、ユーザーはMarkdownでプレゼンテーションの内容を記述するだけで、AIが自動的に最適なレイアウトとデザインを決定し、美しいPowerPointファイルを生成できるようになります。

## 目的

1. **エンドツーエンドパイプラインの完成**: Markdown入力 → LLM構成生成 → 画像生成 → PowerPoint出力
2. **ワークフローフレームワークの構築**: 再利用可能な抽象ワークフロー基底クラス
3. **LLM統合の実現**: 構成生成と画像生成のLLM活用
4. **エラーハンドリングの確立**: 各ステップでの適切なエラー処理とリトライ

## 実装範囲

### 推定規模
- **コード行数**: 約700-900行（コメント・docstring含む）
- **テストコード**: 約600-800行
- **推定工数**: 2-3週（フルタイム1人）

### 依存関係
- ✅ Phase 1: データモデル、LLMManager、FileManager、Serializers
- ✅ Phase 2: PowerPointGenerator、SlideBuilder、Renderers
- ⏳ 新規: ワークフローフレームワーク、CompositionParser、ImageCoordinator

### 対象ファイル

#### 実装ファイル
1. `src/slidemaker/workflows/__init__.py`
2. `src/slidemaker/workflows/base.py` (WorkflowOrchestrator)
3. `src/slidemaker/workflows/new_slide.py` (NewSlideWorkflow)
4. `src/slidemaker/workflows/composition_parser.py` (CompositionParser)
5. `src/slidemaker/workflows/image_coordinator.py` (ImageCoordinator)
6. `src/slidemaker/workflows/exceptions.py` (ワークフロー固有例外)

#### テストファイル
1. `tests/workflows/__init__.py`
2. `tests/workflows/test_new_slide.py`
3. `tests/workflows/test_composition_parser.py`
4. `tests/workflows/test_image_coordinator.py`
5. `tests/workflows/integration/__init__.py`
6. `tests/workflows/integration/test_full_workflow.py`

#### ドキュメントファイル
1. `docs/phase3_summary.md` (Phase 3実装サマリー)
2. `issues/workflow_design.md` (ワークフロー設計書)
3. `examples/sample_input.md` (サンプルMarkdown入力)
4. `CLAUDE.md` (Phase 3完了状態を反映)

---

## 詳細仕様

## 1. WorkflowOrchestrator（基底クラス）

**ファイル**: `src/slidemaker/workflows/base.py`

### 目的
- すべてのワークフローの共通基盤を提供
- ステップ管理、エラーハンドリング、ログ出力の統一
- リトライロジックの実装

### クラス設計

```python
from abc import ABC, abstractmethod
from typing import Any, Callable, TypeVar, Generic
from pathlib import Path
import structlog

from slidemaker.llm.manager import LLMManager
from slidemaker.utils.file_manager import FileManager
from slidemaker.workflows.exceptions import (
    WorkflowError,
    WorkflowStepError,
    WorkflowTimeoutError,
)

T = TypeVar('T')

class WorkflowOrchestrator(ABC):
    """ワークフロー実行の基底クラス

    すべてのワークフロー（NewSlideWorkflow, ConversionWorkflow等）の
    共通基盤を提供します。

    Attributes:
        llm_manager: LLMマネージャー
        file_manager: ファイルマネージャー
        logger: 構造化ロガー
    """

    def __init__(
        self,
        llm_manager: LLMManager,
        file_manager: FileManager,
    ):
        """ワークフローオーケストレーターの初期化

        Args:
            llm_manager: LLMマネージャーインスタンス
            file_manager: ファイルマネージャーインスタンス
        """
        self.llm_manager = llm_manager
        self.file_manager = file_manager
        self.logger = structlog.get_logger(__name__)

    @abstractmethod
    async def execute(self, input_data: Any, output_path: Path, **options) -> Path:
        """ワークフローの実行

        Args:
            input_data: 入力データ（ファイルパスまたはデータオブジェクト）
            output_path: 出力先パス
            **options: ワークフロー固有のオプション

        Returns:
            Path: 生成されたファイルのパス

        Raises:
            WorkflowError: ワークフロー実行エラー
        """
        pass

    async def _run_step(
        self,
        step_name: str,
        step_func: Callable[..., T],
        *args,
        max_retries: int = 3,
        retry_delay: float = 1.0,
        **kwargs
    ) -> T:
        """ステップの実行とエラーハンドリング

        Args:
            step_name: ステップ名（ログ用）
            step_func: 実行する関数
            *args: 関数の位置引数
            max_retries: 最大リトライ回数
            retry_delay: リトライ間隔（秒）
            **kwargs: 関数のキーワード引数

        Returns:
            T: ステップの実行結果

        Raises:
            WorkflowStepError: ステップ実行エラー
        """
        import asyncio

        self.logger.info("workflow_step_start", step=step_name)

        for attempt in range(max_retries):
            try:
                result = await step_func(*args, **kwargs)
                self.logger.info("workflow_step_success", step=step_name)
                return result

            except Exception as e:
                self.logger.warning(
                    "workflow_step_failed",
                    step=step_name,
                    attempt=attempt + 1,
                    max_retries=max_retries,
                    error=str(e),
                )

                if attempt < max_retries - 1:
                    await asyncio.sleep(retry_delay)
                    continue
                else:
                    error_msg = f"Step '{step_name}' failed after {max_retries} attempts: {e}"
                    self.logger.error("workflow_step_exhausted", step=step_name, error=str(e))
                    raise WorkflowStepError(error_msg) from e

    def _validate_input(self, input_data: Any) -> None:
        """入力データのバリデーション

        Args:
            input_data: 入力データ

        Raises:
            ValueError: 入力データが不正な場合
        """
        pass  # サブクラスでオーバーライド

    def _validate_output_path(self, output_path: Path) -> None:
        """出力パスのバリデーション

        Args:
            output_path: 出力先パス

        Raises:
            ValueError: 出力パスが不正な場合
        """
        # FileManagerを使用してパストラバーサル対策
        try:
            self.file_manager.validate_output_path(output_path)
        except Exception as e:
            raise ValueError(f"Invalid output path: {output_path}") from e
```

### エラーハンドリング設計

```python
# src/slidemaker/workflows/exceptions.py

class WorkflowError(Exception):
    """ワークフロー関連のベース例外"""
    pass

class WorkflowStepError(WorkflowError):
    """ワークフローステップ実行エラー"""
    pass

class WorkflowTimeoutError(WorkflowError):
    """ワークフロータイムアウトエラー"""
    pass

class WorkflowValidationError(WorkflowError):
    """ワークフロー入力バリデーションエラー"""
    pass
```

---

## 2. NewSlideWorkflow（新規作成ワークフロー）

**ファイル**: `src/slidemaker/workflows/new_slide.py`

### 目的
- Markdownファイルから最終PowerPointまでの完全パイプライン
- LLMによる構成生成と画像生成の調整
- 各ステップの連携とデータフロー管理

### データフロー

```
Markdown入力
    ↓
1. Markdownパース（MarkdownSerializer使用）
    ↓
2. LLMによる構成生成（LLMManager使用）
    ↓ (composition JSON)
3. CompositionParserでPageDefinition変換
    ↓
4. 画像生成リクエスト抽出
    ↓
5. ImageCoordinatorで画像生成（並行処理）
    ↓ (生成画像パス)
6. PageDefinitionに画像パスを反映
    ↓
7. PowerPointGenerator呼び出し
    ↓
PowerPoint出力
```

### クラス設計

```python
from pathlib import Path
from typing import Any
import structlog

from slidemaker.workflows.base import WorkflowOrchestrator
from slidemaker.workflows.composition_parser import CompositionParser
from slidemaker.workflows.image_coordinator import ImageCoordinator
from slidemaker.core.serializers.markdown import MarkdownSerializer
from slidemaker.core.models.slide_config import SlideConfig
from slidemaker.core.models.page_definition import PageDefinition
from slidemaker.pptx.generator import PowerPointGenerator
from slidemaker.llm.manager import LLMManager
from slidemaker.utils.file_manager import FileManager

class NewSlideWorkflow(WorkflowOrchestrator):
    """Markdownから新規スライド作成ワークフロー

    Markdownファイルを入力として、LLMによる構成生成、
    画像生成、PowerPoint生成を実行します。

    Workflow Steps:
        1. Markdownパース
        2. LLMによる構成生成
        3. CompositionParserで構成解析
        4. 画像生成（必要に応じて）
        5. PowerPoint生成
    """

    def __init__(
        self,
        llm_manager: LLMManager,
        file_manager: FileManager,
    ):
        """NewSlideWorkflowの初期化

        Args:
            llm_manager: LLMマネージャー
            file_manager: ファイルマネージャー
        """
        super().__init__(llm_manager, file_manager)
        self.composition_parser = CompositionParser()
        self.image_coordinator = ImageCoordinator(llm_manager)
        self.markdown_serializer = MarkdownSerializer()
        self.logger = structlog.get_logger(__name__)

    async def execute(
        self,
        markdown_path: Path,
        output_path: Path,
        **options
    ) -> Path:
        """ワークフローの実行

        Args:
            markdown_path: 入力Markdownファイルのパス
            output_path: 出力PowerPointファイルのパス
            **options: オプション
                - theme: テーマ名
                - generate_images: 画像生成を実行するか（デフォルト: False）
                - slide_size: スライドサイズ

        Returns:
            Path: 生成されたPowerPointファイルのパス

        Raises:
            WorkflowError: ワークフロー実行エラー
        """
        self.logger.info(
            "new_slide_workflow_start",
            markdown_path=str(markdown_path),
            output_path=str(output_path),
        )

        # Step 1: Markdownパース
        parsed_data = await self._run_step(
            "parse_markdown",
            self._parse_markdown,
            markdown_path,
        )

        # Step 2: LLMによる構成生成
        composition = await self._run_step(
            "generate_composition",
            self._generate_composition,
            parsed_data,
            options,
        )

        # Step 3: 構成のパースとPageDefinition作成
        slide_config, pages = await self._run_step(
            "parse_composition",
            self._parse_composition,
            composition,
        )

        # Step 4: 画像生成（オプション）
        if options.get("generate_images", False):
            generated_images = await self._run_step(
                "generate_images",
                self._generate_images,
                composition,
            )

            # 画像パスをPageDefinitionに反映
            pages = self._update_image_paths(pages, generated_images)

        # Step 5: PowerPoint生成
        result_path = await self._run_step(
            "generate_powerpoint",
            self._generate_powerpoint,
            slide_config,
            pages,
            output_path,
        )

        self.logger.info(
            "new_slide_workflow_success",
            output_path=str(result_path),
        )

        return result_path

    async def _parse_markdown(self, markdown_path: Path) -> dict[str, Any]:
        """Markdownファイルのパース

        Args:
            markdown_path: Markdownファイルのパス

        Returns:
            dict: パースされたデータ
        """
        if not markdown_path.exists():
            raise FileNotFoundError(f"Markdown file not found: {markdown_path}")

        markdown_content = markdown_path.read_text(encoding="utf-8")

        # TODO: Markdownの構造化パース（見出し、段落、リストなど）
        # 現在はシンプルにテキストとして返す
        return {
            "content": markdown_content,
            "metadata": {
                "source": str(markdown_path),
            },
        }

    async def _generate_composition(
        self,
        parsed_data: dict[str, Any],
        options: dict[str, Any],
    ) -> dict[str, Any]:
        """LLMによる構成生成

        Args:
            parsed_data: パースされたMarkdownデータ
            options: ワークフローオプション

        Returns:
            dict: LLMが生成した構成データ（JSON）
        """
        from slidemaker.llm.prompts.composition import CompositionPrompt

        prompt_builder = CompositionPrompt()
        prompt = prompt_builder.build(
            content=parsed_data["content"],
            theme=options.get("theme"),
            slide_size=options.get("slide_size", "16:9"),
        )

        # LLMによる構造化出力の生成
        composition = await self.llm_manager.generate_structured(
            adapter_name="composition",
            prompt=prompt,
            output_schema={
                "type": "object",
                "properties": {
                    "slide_config": {"type": "object"},
                    "pages": {"type": "array"},
                },
            },
        )

        return composition

    async def _parse_composition(
        self,
        composition: dict[str, Any],
    ) -> tuple[SlideConfig, list[PageDefinition]]:
        """構成データのパースとPageDefinition作成

        Args:
            composition: LLMが生成した構成データ

        Returns:
            tuple: (SlideConfig, list[PageDefinition])
        """
        slide_config = self.composition_parser.parse_slide_config(
            composition.get("slide_config", {})
        )

        pages = self.composition_parser.parse_pages(
            composition.get("pages", [])
        )

        return slide_config, pages

    async def _generate_images(
        self,
        composition: dict[str, Any],
    ) -> dict[str, Path]:
        """画像生成

        Args:
            composition: 構成データ（画像生成リクエスト含む）

        Returns:
            dict: {image_id: generated_path}
        """
        image_requests = self._extract_image_requests(composition)

        if not image_requests:
            return {}

        generated_images = await self.image_coordinator.generate_images(
            image_requests
        )

        return generated_images

    def _extract_image_requests(
        self,
        composition: dict[str, Any],
    ) -> list[dict[str, Any]]:
        """構成データから画像生成リクエストを抽出

        Args:
            composition: 構成データ

        Returns:
            list: 画像生成リクエストのリスト
        """
        requests = []

        for page in composition.get("pages", []):
            for element in page.get("elements", []):
                if element.get("type") == "image" and element.get("generate"):
                    requests.append({
                        "id": element.get("id"),
                        "prompt": element.get("prompt"),
                        "size": element.get("size"),
                    })

        return requests

    def _update_image_paths(
        self,
        pages: list[PageDefinition],
        generated_images: dict[str, Path],
    ) -> list[PageDefinition]:
        """PageDefinitionに生成された画像パスを反映

        Args:
            pages: PageDefinitionのリスト
            generated_images: {image_id: generated_path}

        Returns:
            list: 更新されたPageDefinitionのリスト
        """
        # TODO: 画像要素のsourceフィールドを更新
        return pages

    async def _generate_powerpoint(
        self,
        slide_config: SlideConfig,
        pages: list[PageDefinition],
        output_path: Path,
    ) -> Path:
        """PowerPointファイルの生成

        Args:
            slide_config: スライド設定
            pages: ページ定義のリスト
            output_path: 出力先パス

        Returns:
            Path: 生成されたファイルのパス
        """
        generator = PowerPointGenerator(slide_config)
        result_path = generator.generate(pages, output_path)

        return result_path
```

---

## 3. CompositionParser（構成パーサー）

**ファイル**: `src/slidemaker/workflows/composition_parser.py`

### 目的
- LLMが生成したJSON構成データをバリデーション
- Pydanticモデル（SlideConfig, PageDefinition）への変換
- エラーハンドリングとデータ正規化

### クラス設計

```python
from typing import Any
from pydantic import ValidationError
import structlog

from slidemaker.core.models.slide_config import SlideConfig
from slidemaker.core.models.page_definition import PageDefinition
from slidemaker.core.models.element import TextElement, ImageElement
from slidemaker.core.models.common import Position, Size, Color, Alignment, FitMode
from slidemaker.workflows.exceptions import WorkflowValidationError

class CompositionParser:
    """LLM生成の構成データをパースしてPydanticモデルに変換

    LLMが生成したJSON構成データをバリデーションし、
    SlideConfigとPageDefinitionに変換します。
    """

    def __init__(self):
        """CompositionParserの初期化"""
        self.logger = structlog.get_logger(__name__)

    def parse_slide_config(self, config_data: dict[str, Any]) -> SlideConfig:
        """SlideConfigのパース

        Args:
            config_data: LLM生成のスライド設定データ

        Returns:
            SlideConfig: パースされたスライド設定

        Raises:
            WorkflowValidationError: バリデーションエラー
        """
        try:
            # デフォルト値の設定
            normalized = self._normalize_slide_config(config_data)

            # Pydanticモデルに変換
            slide_config = SlideConfig(**normalized)

            self.logger.debug("slide_config_parsed", config=slide_config)
            return slide_config

        except ValidationError as e:
            error_msg = f"Failed to parse slide config: {e}"
            self.logger.error("slide_config_parse_error", error=str(e))
            raise WorkflowValidationError(error_msg) from e

    def parse_pages(self, pages_data: list[dict[str, Any]]) -> list[PageDefinition]:
        """PageDefinitionのパース

        Args:
            pages_data: LLM生成のページデータのリスト

        Returns:
            list[PageDefinition]: パースされたページ定義のリスト

        Raises:
            WorkflowValidationError: バリデーションエラー
        """
        pages = []

        for i, page_data in enumerate(pages_data):
            try:
                normalized = self._normalize_page(page_data, page_number=i + 1)
                page = PageDefinition(**normalized)
                pages.append(page)

            except ValidationError as e:
                error_msg = f"Failed to parse page {i + 1}: {e}"
                self.logger.error("page_parse_error", page_number=i + 1, error=str(e))
                raise WorkflowValidationError(error_msg) from e

        self.logger.info("pages_parsed", count=len(pages))
        return pages

    def _normalize_slide_config(self, data: dict[str, Any]) -> dict[str, Any]:
        """SlideConfigデータの正規化

        Args:
            data: 生データ

        Returns:
            dict: 正規化されたデータ
        """
        return {
            "size": data.get("size", "16:9"),
            "theme": data.get("theme", "default"),
            # 他のフィールドも必要に応じて追加
        }

    def _normalize_page(
        self,
        data: dict[str, Any],
        page_number: int,
    ) -> dict[str, Any]:
        """PageDefinitionデータの正規化

        Args:
            data: 生データ
            page_number: ページ番号

        Returns:
            dict: 正規化されたデータ
        """
        # 要素のパース
        elements = []
        for elem_data in data.get("elements", []):
            element = self._parse_element(elem_data)
            if element:
                elements.append(element)

        return {
            "page_number": page_number,
            "title": data.get("title", ""),
            "background_color": data.get("background_color"),
            "background_image": data.get("background_image"),
            "elements": elements,
        }

    def _parse_element(self, data: dict[str, Any]) -> TextElement | ImageElement | None:
        """要素のパース

        Args:
            data: 要素データ

        Returns:
            TextElement | ImageElement | None: パースされた要素
        """
        element_type = data.get("type")

        if element_type == "text":
            return self._parse_text_element(data)
        elif element_type == "image":
            return self._parse_image_element(data)
        else:
            self.logger.warning("unknown_element_type", type=element_type)
            return None

    def _parse_text_element(self, data: dict[str, Any]) -> TextElement:
        """TextElementのパース

        Args:
            data: テキスト要素データ

        Returns:
            TextElement: パースされたテキスト要素
        """
        from slidemaker.core.models.element import FontConfig

        return TextElement(
            position=Position(
                x=data["position"]["x"],
                y=data["position"]["y"],
            ),
            size=Size(
                width=data["size"]["width"],
                height=data["size"]["height"],
            ),
            content=data["content"],
            font=FontConfig(
                family=data.get("font", {}).get("family", "Arial"),
                size=data.get("font", {}).get("size", 18),
                color=data.get("font", {}).get("color", "#000000"),
                bold=data.get("font", {}).get("bold", False),
                italic=data.get("font", {}).get("italic", False),
                underline=data.get("font", {}).get("underline", False),
            ),
            alignment=Alignment(data.get("alignment", "left")),
            z_index=data.get("z_index", 0),
        )

    def _parse_image_element(self, data: dict[str, Any]) -> ImageElement:
        """ImageElementのパース

        Args:
            data: 画像要素データ

        Returns:
            ImageElement: パースされた画像要素
        """
        return ImageElement(
            position=Position(
                x=data["position"]["x"],
                y=data["position"]["y"],
            ),
            size=Size(
                width=data["size"]["width"],
                height=data["size"]["height"],
            ),
            source=data["source"],
            fit_mode=FitMode(data.get("fit_mode", "contain")),
            z_index=data.get("z_index", 0),
        )
```

---

## 4. ImageCoordinator（画像生成コーディネーター）

**ファイル**: `src/slidemaker/workflows/image_coordinator.py`

### 目的
- 複数の画像生成リクエストを管理
- 並行生成による効率化
- 生成結果のキャッシュとエラーハンドリング

### クラス設計

```python
import asyncio
from pathlib import Path
from typing import Any
import structlog

from slidemaker.llm.manager import LLMManager
from slidemaker.workflows.exceptions import WorkflowError

class ImageCoordinator:
    """画像生成の調整と管理

    複数の画像生成リクエストを並行実行し、
    結果をキャッシュして効率的に処理します。
    """

    def __init__(self, llm_manager: LLMManager):
        """ImageCoordinatorの初期化

        Args:
            llm_manager: LLMマネージャー
        """
        self.llm_manager = llm_manager
        self.logger = structlog.get_logger(__name__)
        self._cache: dict[str, Path] = {}

    async def generate_images(
        self,
        image_requests: list[dict[str, Any]],
        max_concurrent: int = 3,
    ) -> dict[str, Path]:
        """複数画像の生成

        Args:
            image_requests: 画像生成リクエストのリスト
                [{"id": "img1", "prompt": "...", "size": "1024x1024"}, ...]
            max_concurrent: 最大同時実行数

        Returns:
            dict: {image_id: generated_path}

        Raises:
            WorkflowError: 画像生成エラー
        """
        if not image_requests:
            return {}

        self.logger.info(
            "image_generation_start",
            count=len(image_requests),
            max_concurrent=max_concurrent,
        )

        # セマフォで並行実行数を制限
        semaphore = asyncio.Semaphore(max_concurrent)

        tasks = [
            self._generate_with_semaphore(request, semaphore)
            for request in image_requests
        ]

        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 結果の集約
        generated_images = {}
        errors = []

        for request, result in zip(image_requests, results):
            if isinstance(result, Exception):
                errors.append((request["id"], result))
                self.logger.error(
                    "image_generation_failed",
                    image_id=request["id"],
                    error=str(result),
                )
            else:
                generated_images[request["id"]] = result
                self.logger.debug(
                    "image_generated",
                    image_id=request["id"],
                    path=str(result),
                )

        if errors:
            error_msg = f"Failed to generate {len(errors)} images: {errors}"
            self.logger.warning("image_generation_partial_failure", errors=errors)
            # 一部失敗でもワークフローは続行（空のパスを返す）

        self.logger.info(
            "image_generation_complete",
            success=len(generated_images),
            failed=len(errors),
        )

        return generated_images

    async def _generate_with_semaphore(
        self,
        request: dict[str, Any],
        semaphore: asyncio.Semaphore,
    ) -> Path:
        """セマフォ付き画像生成

        Args:
            request: 画像生成リクエスト
            semaphore: 並行実行制御用セマフォ

        Returns:
            Path: 生成された画像のパス
        """
        async with semaphore:
            return await self._generate_single_image(request)

    async def _generate_single_image(self, request: dict[str, Any]) -> Path:
        """単一画像の生成

        Args:
            request: 画像生成リクエスト
                {"id": "img1", "prompt": "...", "size": "1024x1024"}

        Returns:
            Path: 生成された画像のパス

        Raises:
            WorkflowError: 画像生成エラー
        """
        image_id = request["id"]

        # キャッシュチェック
        if image_id in self._cache:
            self.logger.debug("image_cache_hit", image_id=image_id)
            return self._cache[image_id]

        # LLMによる画像生成
        prompt = request["prompt"]
        size = request.get("size", "1024x1024")

        try:
            # TODO: 実際の画像生成LLMアダプタを使用
            # 現在はプレースホルダー
            image_path = Path(f"generated_{image_id}.png")

            # キャッシュに保存
            self._cache[image_id] = image_path

            return image_path

        except Exception as e:
            error_msg = f"Failed to generate image '{image_id}': {e}"
            raise WorkflowError(error_msg) from e
```

---

## テスト計画

### テストカバレッジ目標
- **ユニットテスト**: 80%以上
- **統合テスト**: 主要ワークフロー100%
- **E2Eテスト**: Markdown → PowerPoint 100%

### 1. ユニットテスト

#### tests/workflows/test_new_slide.py
```python
"""NewSlideWorkflowのユニットテスト"""

import pytest
from pathlib import Path
from unittest.mock import AsyncMock, Mock

from slidemaker.workflows.new_slide import NewSlideWorkflow
from slidemaker.llm.manager import LLMManager
from slidemaker.utils.file_manager import FileManager

@pytest.fixture
def workflow(tmp_path):
    """NewSlideWorkflowのフィクスチャ"""
    llm_manager = Mock(spec=LLMManager)
    file_manager = FileManager(output_base_dir=tmp_path)
    return NewSlideWorkflow(llm_manager, file_manager)

@pytest.mark.asyncio
async def test_parse_markdown(workflow, tmp_path):
    """Markdownパースのテスト"""
    # テスト用Markdownファイル作成
    md_file = tmp_path / "test.md"
    md_file.write_text("# Test Slide\n\nContent here", encoding="utf-8")

    result = await workflow._parse_markdown(md_file)

    assert "content" in result
    assert "# Test Slide" in result["content"]

@pytest.mark.asyncio
async def test_generate_composition(workflow):
    """構成生成のテスト（モックLLM）"""
    workflow.llm_manager.generate_structured = AsyncMock(return_value={
        "slide_config": {"size": "16:9"},
        "pages": [{"title": "Slide 1", "elements": []}],
    })

    parsed_data = {"content": "test content"}
    result = await workflow._generate_composition(parsed_data, {})

    assert "slide_config" in result
    assert "pages" in result

@pytest.mark.asyncio
async def test_execute_full_workflow(workflow, tmp_path):
    """完全ワークフローのテスト（モック使用）"""
    # モック設定
    workflow._parse_markdown = AsyncMock(return_value={"content": "test"})
    workflow._generate_composition = AsyncMock(return_value={
        "slide_config": {},
        "pages": [],
    })
    workflow._parse_composition = AsyncMock(return_value=(Mock(), []))
    workflow._generate_powerpoint = AsyncMock(return_value=tmp_path / "output.pptx")

    md_path = tmp_path / "input.md"
    md_path.write_text("# Test", encoding="utf-8")
    output_path = tmp_path / "output.pptx"

    result = await workflow.execute(md_path, output_path)

    assert result == output_path
```

#### tests/workflows/test_composition_parser.py
```python
"""CompositionParserのユニットテスト"""

import pytest
from slidemaker.workflows.composition_parser import CompositionParser
from slidemaker.workflows.exceptions import WorkflowValidationError

@pytest.fixture
def parser():
    """CompositionParserのフィクスチャ"""
    return CompositionParser()

def test_parse_slide_config(parser):
    """SlideConfigパースのテスト"""
    data = {
        "size": "16:9",
        "theme": "corporate",
    }

    config = parser.parse_slide_config(data)

    assert config.size == "16:9"
    assert config.theme == "corporate"

def test_parse_slide_config_with_defaults(parser):
    """デフォルト値を使用したSlideConfigパースのテスト"""
    data = {}

    config = parser.parse_slide_config(data)

    assert config.size == "16:9"  # デフォルト値

def test_parse_pages(parser):
    """ページパースのテスト"""
    data = [
        {
            "title": "Slide 1",
            "elements": [
                {
                    "type": "text",
                    "position": {"x": 100, "y": 200},
                    "size": {"width": 800, "height": 100},
                    "content": "Hello World",
                }
            ],
        }
    ]

    pages = parser.parse_pages(data)

    assert len(pages) == 1
    assert pages[0].title == "Slide 1"
    assert len(pages[0].elements) == 1

def test_parse_pages_invalid_data(parser):
    """不正なデータでのパースエラーテスト"""
    data = [
        {
            "title": "Invalid Slide",
            "elements": [
                {
                    "type": "text",
                    # position, size, content が欠落
                }
            ],
        }
    ]

    with pytest.raises(WorkflowValidationError):
        parser.parse_pages(data)
```

#### tests/workflows/test_image_coordinator.py
```python
"""ImageCoordinatorのユニットテスト"""

import pytest
from pathlib import Path
from unittest.mock import AsyncMock, Mock

from slidemaker.workflows.image_coordinator import ImageCoordinator
from slidemaker.llm.manager import LLMManager

@pytest.fixture
def coordinator():
    """ImageCoordinatorのフィクスチャ"""
    llm_manager = Mock(spec=LLMManager)
    return ImageCoordinator(llm_manager)

@pytest.mark.asyncio
async def test_generate_images_empty(coordinator):
    """空のリクエストのテスト"""
    result = await coordinator.generate_images([])

    assert result == {}

@pytest.mark.asyncio
async def test_generate_images_single(coordinator):
    """単一画像生成のテスト"""
    requests = [
        {"id": "img1", "prompt": "A cat", "size": "1024x1024"}
    ]

    # モック設定
    coordinator._generate_single_image = AsyncMock(
        return_value=Path("generated_img1.png")
    )

    result = await coordinator.generate_images(requests)

    assert "img1" in result
    assert result["img1"] == Path("generated_img1.png")

@pytest.mark.asyncio
async def test_generate_images_concurrent(coordinator):
    """並行生成のテスト"""
    requests = [
        {"id": f"img{i}", "prompt": f"Image {i}", "size": "1024x1024"}
        for i in range(5)
    ]

    # モック設定
    coordinator._generate_single_image = AsyncMock(
        side_effect=lambda req: Path(f"generated_{req['id']}.png")
    )

    result = await coordinator.generate_images(requests, max_concurrent=2)

    assert len(result) == 5
    for i in range(5):
        assert f"img{i}" in result

@pytest.mark.asyncio
async def test_generate_images_with_cache(coordinator):
    """キャッシュ動作のテスト"""
    requests = [
        {"id": "img1", "prompt": "A cat", "size": "1024x1024"}
    ]

    # 最初の生成
    coordinator._generate_single_image = AsyncMock(
        return_value=Path("generated_img1.png")
    )
    result1 = await coordinator.generate_images(requests)

    # 2回目（キャッシュヒット）
    result2 = await coordinator.generate_images(requests)

    assert result1 == result2
    # _generate_single_imageは1回だけ呼ばれる
    coordinator._generate_single_image.assert_called_once()
```

### 2. 統合テスト

#### tests/workflows/integration/test_full_workflow.py
```python
"""ワークフロー統合テスト"""

import pytest
from pathlib import Path

from slidemaker.workflows.new_slide import NewSlideWorkflow
from slidemaker.llm.manager import LLMManager
from slidemaker.utils.file_manager import FileManager
from slidemaker.utils.config_loader import ConfigLoader

@pytest.fixture
def integration_workflow(tmp_path):
    """統合テスト用のワークフロー"""
    # 実際のコンポーネントを使用（LLMはモック）
    config_loader = ConfigLoader()
    config = config_loader.load()

    llm_manager = LLMManager(config.llm)
    file_manager = FileManager(output_base_dir=tmp_path)

    return NewSlideWorkflow(llm_manager, file_manager)

@pytest.mark.asyncio
@pytest.mark.integration
async def test_markdown_to_powerpoint_e2e(integration_workflow, tmp_path):
    """Markdown → PowerPoint のE2Eテスト"""
    # テスト用Markdownファイル作成
    md_file = tmp_path / "test.md"
    md_file.write_text("""
# Test Presentation

## Slide 1: Introduction
This is the first slide.

## Slide 2: Content
This is the second slide with some content.
""", encoding="utf-8")

    output_path = tmp_path / "output.pptx"

    # モックLLMレスポンス設定
    integration_workflow.llm_manager.generate_structured = AsyncMock(return_value={
        "slide_config": {
            "size": "16:9",
            "theme": "default",
        },
        "pages": [
            {
                "title": "Introduction",
                "elements": [
                    {
                        "type": "text",
                        "position": {"x": 100, "y": 200},
                        "size": {"width": 800, "height": 100},
                        "content": "This is the first slide.",
                    }
                ],
            },
            {
                "title": "Content",
                "elements": [
                    {
                        "type": "text",
                        "position": {"x": 100, "y": 200},
                        "size": {"width": 800, "height": 100},
                        "content": "This is the second slide with some content.",
                    }
                ],
            },
        ],
    })

    # ワークフロー実行
    result = await integration_workflow.execute(
        md_file,
        output_path,
        generate_images=False,
    )

    # 検証
    assert result.exists()
    assert result.suffix == ".pptx"
    assert result.stat().st_size > 0
```

---

## 実装順序

### Week 1: 基盤構築
1. ✅ `src/slidemaker/workflows/__init__.py` 作成
2. ✅ `src/slidemaker/workflows/exceptions.py` 実装
3. ✅ `src/slidemaker/workflows/base.py` 実装（WorkflowOrchestrator）
4. ✅ `tests/workflows/test_base.py` 実装
5. ✅ `src/slidemaker/workflows/composition_parser.py` 実装
6. ✅ `tests/workflows/test_composition_parser.py` 実装

### Week 2: ワークフロー実装
7. ✅ `src/slidemaker/workflows/image_coordinator.py` 実装
8. ✅ `tests/workflows/test_image_coordinator.py` 実装
9. ✅ `src/slidemaker/workflows/new_slide.py` 実装
10. ✅ `tests/workflows/test_new_slide.py` 実装

### Week 3: 統合とドキュメント
11. ✅ 統合テスト実装（`tests/workflows/integration/test_full_workflow.py`）
12. ✅ サンプルMarkdown作成（`examples/sample_input.md`）
13. ✅ ワークフロー設計書作成（`issues/workflow_design.md`）
14. ✅ Phase 3サマリー作成（`docs/phase3_summary.md`）
15. ✅ CLAUDE.md更新（Phase 3完了状態を反映）

---

## 成功基準

### 機能要件
- ✅ Markdownファイルから正常にPowerPointファイルが生成できる
- ✅ LLMによる構成生成が正しく動作する
- ✅ 画像生成リクエストの抽出と並行生成が機能する
- ✅ エラーハンドリングとリトライが適切に動作する
- ✅ ログ出力が適切に行われる

### 品質要件
- ✅ ユニットテストカバレッジ 80%以上
- ✅ すべての統合テストがパス
- ✅ E2Eテスト（Markdown → PowerPoint）がパス
- ✅ リンター（ruff）がパス
- ✅ 型チェッカー（mypy）がパス
- ✅ すべてのdocstringが記述されている

### パフォーマンス要件
- ✅ 10スライドの生成が1分以内に完了する
- ✅ 画像生成の並行実行により生成時間が短縮される
- ✅ メモリ使用量が適切に管理される

---

## 制約事項と注意点

### 技術的制約
1. **LLM出力の不確実性**: LLMの出力が常に期待通りとは限らないため、堅牢なバリデーションが必要
2. **画像生成の時間**: 画像生成は時間がかかるため、並行実行とタイムアウト設定が重要
3. **非同期処理**: async/awaitの適切な使用とエラーハンドリングが必要

### セキュリティ考慮事項
1. **パストラバーサル対策**: FileManagerを使用してファイルパスを検証
2. **入力バリデーション**: すべてのLLM出力とユーザー入力をバリデーション
3. **エラーメッセージ**: 機密情報を含まないエラーメッセージ

### 今後の拡張予定
1. **Phase 4との連携**: PDF/画像変換ワークフローとの統合
2. **テンプレート機能**: 複数のテーマとテンプレートのサポート
3. **バッチ処理**: 複数のMarkdownファイルの一括処理
4. **プレビュー機能**: PowerPoint生成前のプレビュー表示

---

## 関連ドキュメント

- [Phase 1実装サマリー](../docs/phase1_summary.md)
- [Phase 2実装サマリー](../docs/phase2_summary.md)
- [実装ロードマップ](PLAN01/06_implementation_roadmap.md)
- [アーキテクチャ設計](PLAN01/01_architecture.md)

---

**作成日**: 2025-12-21
**作成者**: Claude Code + Project Team
**ステータス**: Phase 3実装計画 - 準備完了
